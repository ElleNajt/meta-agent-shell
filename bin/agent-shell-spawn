#!/bin/bash
# agent-shell-spawn - Spawn a new named agent
# Usage: agent-shell-spawn "AgentName" ["initial task"]
#
# Spawns agent in the calling agent's project (via PID lookup).
# Falls back to current directory if not called from an agent.
# Includes spawner identity so new agent knows who to report back to.

if [ $# -lt 1 ]; then
    echo "Usage: agent-shell-spawn \"AgentName\" [\"initial task\"]" >&2
    exit 1
fi

name="$1"
task="${2:-}"

# Get spawner identity
spawner=$(emacsclient --eval "(meta-agent-shell-whoami $$)" 2>/dev/null | tr -d '"')
if [ "$spawner" = "nil" ] || [ -z "$spawner" ]; then
    spawner="unknown"
fi

# Get project path from calling agent's buffer, fall back to pwd
project_path=$(emacsclient --eval "(meta-agent-shell-project-path $$)" 2>/dev/null | tr -d '"')
if [ "$project_path" = "nil" ] || [ -z "$project_path" ]; then
    project_path="$(pwd)"
fi

# Escape for elisp: backslashes first, then quotes
escape_elisp() {
    printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g'
}

escaped_path=$(escape_elisp "$project_path")
escaped_name=$(escape_elisp "$name")

# Format initial message with spawner info
if [ -n "$task" ]; then
    initial_message="Spawned by: $spawner

Task: $task"
    escaped_message=$(escape_elisp "$initial_message")
    emacsclient --eval "(meta-agent-shell-start-named-agent \"$escaped_path\" \"$escaped_name\" \"$escaped_message\")"
else
    emacsclient --eval "(meta-agent-shell-start-named-agent \"$escaped_path\" \"$escaped_name\")"
fi
